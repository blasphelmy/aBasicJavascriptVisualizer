<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script
      src="https://code.jquery.com/jquery-3.6.0.js"
      integrity="sha256-H+K7U5CnXl1h5ywQfKtSj8PCmoN9aaq30gDh27Xc0jk="
      crossorigin="anonymous"
    ></script>
    <script src="tools.js"></script>
    <link rel="stylesheet" href="style.css" />
    <title>parse</title>
  </head>
  <body>
    <div id="mainWrapper">
      <div id="inputSection">
        <p>Howdy Team</p>

        <textarea id="inputTextArea" style="width: 300px; height: 400px">
var globalNum0 = 0;
var globalNum1 = 0;

function oneLvlFunc0 () {
  var oneDeepNum0 = 1;
}

function oneLvlFunc1 () {
  var oneDeepNum1 = 1;
  function twoLvlFunc0 () {
    var twoDeepNum0 = 2;
  }
}

oneLvlFunc0();
oneLvlFunc1();
              </textarea
        >
        <br />
        <button id="runBtn">Run Code</button>
      </div>

      <div id="outputSection"></div>
    </div>
  </body>

  <script>
    window.addEventListener("load", () => {
      appMain();
    });

    let runBtn;
    let inputSection;
    let inputString;
    let instructions;
    let frames = [];

    function appMain() {
      getElements();
      addListeners();
      run();
    }

    function getElements() {
      inputSection = document.getElementById("inputTextArea");
      runBtn = document.getElementById("runBtn");
    }

    function addListeners() {
      runBtn.addEventListener("click", run, false);
    }

    function run() {
      frames = [];
      inputString = inputSection.textContent;
      console.log(inputString);
      instructions = parseInstructions(inputString);
      createFrames();
    }

    function parseInstructions(inputString) {
      // Split into lines
      let lines = inputString.split(/\n+/);

      // Trim tabs/exterior spaces
      for (let i = 0; i < lines.length; i++) {
        lines[i] = lines[i].trim();
      }

      // Remove any remaining empty lines ("") from array
      lines = lines.filter((ex) => ex != "");

      // Split expressions into 'words'
      let words = [];
      let delimiters = [" ", "=", ",", ";", "(", ")", "{", "}"];

      lines.forEach((ex) => {
        let foot = 0;
        for (let i = 0; i < ex.length; i++) {
          if (delimiters.includes(ex[i])) {
            if (foot == i) {
              words.push(ex[i]); // Single char words, like = ; and (
            } else {
              words.push(ex.slice(foot, i));
            }
            foot = i + 1;
          }
        }
      });

      words = words.filter((word) => word != " ");

      return words;
    }

    function createFrames() {
      let globalFrame = new Frame("Global");
      let startReadingFrom = 0;
      fillFrame(globalFrame, startReadingFrom);
      //console.log(frames);
    }

    function fillFrame(frame, startReadingFrom) {
      // Where does global frame get pushed to frames?

      for (let i = startReadingFrom; i < instructions.length; i++) {
        // Push frame at closing brace }
        if (instructions[i] == "}") {
          frames.push(frame);
          return frame;
        }

        // Continue if semicolon ;
        if (instructions[i] == ";") {
          i++;
        }

        // Parse Function
        if (instructions[i] == "function") {
          i++;
          let functionName = instructions[i];
          let childFrame = new Frame(functionName); // Id = function name
          childFrame.parent = frame;
          i++;
          if (instructions[i] == "(") i++;
          // Check for parameters
          if (instructions[i] == ")") i++;
          if (instructions[i] == "{") {
            i++;
            frame.children.push(fillFrame(childFrame, i));
          }

          // Skip to closing brace
          while (
            instructions[i] != "}" ||
            instructions[i] < instructions.length
          ) {
            i++;
          }
        }

        let variableKeywords = ["var", "let", "const"];

        // Parse Variable (In local scope)
        if (variableKeywords.includes(instructions[i])) {
          let newVariable = new Variable(instructions[i]);
          i++;
          newVariable.name = instructions[i];
          i++;
          if (instructions[i] == "=") i++;
          else {
            console.log("Expected assignment");
            return;
          }
          newVariable.value = instructions[i];
          if (instructions[i] == ";") i++;
          frame.variables.push(newVariable);
        }
      }
    }

    class Variable {
      type;
      name;
      value;

      constructor(type) {
        this.type = type;
      }
    }

    class Frame {
      id;
      parent;
      variables;
      children;
      callStack;

      constructor(id) {
        this.id = id;
        this.variables = [];
        this.children = [];
      }
    }

    // End script
  </script>

  <!-- <script>
    window.addEventListener("load", function () {
      ///////////////////////////////////////building a statement then excuting it... this sets a new variable String xyz = "helloworld..."
      var newStatementStack = new statementStack(); //needs more work
      newStatementStack.addNode(new value(2));
      newStatementStack.addNode(new multiply());
      newStatementStack.addNode(new value(4));
      newStatementStack.addNode(new multiply());
      newStatementStack.addNode(new value(3));
      console.log(newStatementStack.pop(1));

      // console.log(newStatementStack.getStackNodeIndexOf(1));

      var globalFrame = new frame("global", 0); //i guess the function name for global frame is global.
      globalFrame.addVariables(new variable("integer1", 45));
      globalFrame.addVariables(new variable("integer2", 34));
      globalFrame.addVariables(new variable("string1", "hello"));
      globalFrame.addStatements(newStatementStack);
      globalFrame.addStatements(newStatementStack);
      globalFrame.addStatements(newStatementStack);

      var newFunction = new functions("newFunction");

      globalFrame.addFunction(newFunction);
      globalFrame.addFunction(newFunction);

      console.log(globalFrame);
    });
    function parseArray(array) {
      for (var index = 0; index < array.length; index++) {
        if (isFunction(array[index])) {
          var start = index;
          //console.log("is function at index: " + index + " and ends on line "+ findEOFLine(array, start));
        } else if (isVarDeclartion(array[index])) {
          console.log(
            "is variable declartion at index: " +
              index +
              " null declaration " +
              isVarDeclartion(array[index])
          );
        }
      }
    }
    function isFunction(string) {
      var isFunctionDeclartion = new RegExp(/((function) +[a-z,A-Z,0-9]*)/gim);
      //make improvements to this regexp here : https://regex101.com/r/9IiFmz/1
      return isFunctionDeclartion.test(string);
    }
    function isVarDeclartion(string) {
      //-1 for false, 0 var declared w/o assignment, 1 var declared /w assignment
      const isVariableDeclartionWithAssignment = new RegExp(
        /(var[ ]*[a-z, A-Z, 0-9]*[=][ ]*[a-z, A-Z, 0-9,+,-,*,/,",']*[;])/gm
      );
      //improve this regexp here https://regex101.com/r/FjoVKw/1
      const isVarDeclarNoAssignment = new RegExp(
        /(var[ ]*[a-z, A-Z, 0-9]*[;])/gm
      );
      //improve this regexp here https://regex101.com/r/T97bkY/1 //please add onto links. dont delete any previous if youre making changes.
      //console.log(isVarDeclarNoAssignment.test(string), string);
      if (isVarDeclarNoAssignment.test(string)) {
        return "isNullValue";
      }
      if (isVariableDeclartionWithAssignment.test(string) == true) {
        return "hasValue";
      }
    }
    function evaluteStack(statementStack) {
      //we first figure out what kind of statement it is...variable declaration,
    }
    function findEOFLine(array, start) {
      //raw string -> breakIntoComponents() first. start is the index of the array where a function declartion is detected.
      var count = 0;
      var endLine = -1;
      for (var x = start; x < array.length; x++) {
        if (array[x].search("{") > -1) {
          count = count + 1;
        }
        if (array[x].search("}") > -1) {
          count = count - 1;
        }
        if (count === 0 && array[x].search("}") > -1) {
          endLine = x;
          break;
        }
        // console.log(count);
      }
      return endLine;
    }
    function returnFunction(array) {}
    //**important notes: on a function call you will always need to initialize a the corrosponding frame... how?
    class frame {
      //a frame may contain variables, functions....or...maybe a callStack...
      frameIndex;
      id; //name
      size; //this tracks something...im not sure yet
      variables; //is an map [key, value] = [variablename, value]
      functions; //is an map ....//[functionName, functionFrame]
      previousNodeFrame; //a frame can only have one parent right...? this always leads back to the global...
      callStack;
      constructor(aFunctionName, index) {
        this.variables = new Map();
        this.functions = new Map();
        this.callStack = new Array();
        this.id = aFunctionName;
        this.frameIndex = index;
      }
      addVariables(variable) {
        //accepts an object of variable type
        // this.variables.push([variable.name,variable.value]);
        this.variables.set(variable.name, variable.value);
      }
      addFunction(newFunction) {
        //whenever you add a function (through encountering a function declaration token within this frame's context) you must create a new frame for everything in this function...i think
        var newFrame = new frame(newFunction.name + "_" + this.frameIndex); //we can also return the new frame created.
        newFrame.previousNodeFrame = this;
        this.functions.set(newFunction.name, newFrame);
      }
      addStatements(statementStack) {
        //is an object of statementStack
        this.callStack.push(statementStack);
      }
      returnChildFrame(id) {
        return this.functions.get(id);
      }
      returnParentFrame() {
        return this.previousNodeFrame;
      }
      eval() {}
      class;
    }
    class statementStack {
      size; //size of this stack
      statementHead; //always points back to the original head of this stack
      statementTail; //always points to the tail of this stack
      constructor() {
        //of a variable declartion, //function declarations/calls, variable name, valid pointers to objects basically.
        this.statementHead = null;
        this.statementTail = null;
        this.size = 0;
      }
      addNode(newNode) {
        //lets imagine the first
        if (this.statementHead === null) {
          //
          this.statementHead = newNode;
        } else if (this.statementTail === null) {
          this.statementTail = newNode;
          this.statementTail.previousNode = this.statementHead;
          this.statementHead.nextNode = this.statementTail;
        } else {
          // console.log("this newNode=", newNode);
          this.statementTail.nextNode = newNode;
          newNode.previousNode = this.statementTail;
          this.statementTail = newNode;
        }
        this.size++;
      }
      pop(index) {
        //if user provides no index input it pops the tail and returns it...
        console.log(index);
      }
      getStackNodeIndexOf(index) {
        var newStatementStack = null;
        var counter = 0;
        var temp = this.statementHead;
        // console.log(this);
        while (temp.nextNode != undefined) {
          temp = temp.nextNode;
          if (counter === index) {
            return temp;
          }
          counter++;
        }
        return "error";
      }
    }
    class functions {
      name; //what is your name
      nextNode; //ie var x = 2 or another function call ->this needs to be mapped to
      previousNode; //where did you come from?
      constructor(name) {
        this.name = name;
      }
    }
    class variable {
      type; //int, float, double, String is type even needed in javascript?? for simplicity's sake, please lets just get rid of types and only use strings.
      name; //what is your name?
      value; //what value do you store?
      nextNode; //next command.
      previousNode; //points to previous statement...?
      constructor(name, value) {
        //the minimum you need to declare a variable
        this.name = name;
        this.value = value;
      }
    }
    class value {
      value; //what is your value? a string? integer? float? i guess we could use javascript's amazingly flexible handling of types here...
      previousNode; //points to an arithmatic operation or to a variable...
      nextNode; //next node. a number sitting next to each other never makes sense. so a number have to be lead by and folowed by some sort of arithmatic
      constructor(value) {
        this.value = value;
      }
      addNode(newNode) {
        newNode.previousNode = this;
        this.nextNode = newNode;
      }
    }
    class equal {
      name;
      previousNode; //points to an object of either value() or variable();
      nextNode; //same here
      constructor() {
        this.name = "=";
      }
      eval() {
        this.previousNode.value = this.nextNode.value;
      }
    }
    class multiply {
      name;
      previousNode; //points to an object of either value() or variable();
      nextNode; //same here
      constructor() {
        this.name = "*";
      }
    }
    class add {
      name;
      constructor() {
        this.name = "+";
      }
    }
    class subtract {
      name;
      constructor() {
        this.name = "-";
      }
      eval() {
        return this.previousNode.value - this.nextNode.value;
      }
    }
    class divide {
      name;
      constructor() {
        this.name = "/";
      }
    }
  </script> -->
</html>
