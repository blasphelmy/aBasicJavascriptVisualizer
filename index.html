<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script
      src="https://code.jquery.com/jquery-3.6.0.js"
      integrity="sha256-H+K7U5CnXl1h5ywQfKtSj8PCmoN9aaq30gDh27Xc0jk="
      crossorigin="anonymous"
    ></script>
    <script src="tools.js"></script>
    <link rel="stylesheet" href="style.css" />
    <title>parse</title>
  </head>
  <body>
    <div id="mainWrapper">
      <div id="inputSection">
        <p>Howdy Team</p>
        <!-- var a = 2+2;
              console.log(a); -->
        <textarea id="inputTextArea" style="width: 300px; height: 400px">
var a = 10;
var vark = 10;

function b(){
a = 5;  
c();
console.log(d);
}
function c(){
d = 6;
var a = 7;
e = 9;
function f(){
    a = 2;
}
f();
}
b();
              </textarea
        >
        <br />
        <button id="runBtn">Run Code</button>
      </div>

      <div id="outputSection"></div>
    </div>

    <!-- var VAR_0a = 0;
function FUNCT_0a(){
    var VAR_1a = 34;
    function FUNCT_1a(){
        var VAR_2a = 34;
    }
}
function FUNCT_0b(){

}
var VAR_0b = 3;
console.log(""); -->
  </body>

  <script>
    // Get input string from input section
    let runBtn;
    let inputString;
    let statements;
    let frames;

    function appMain() {
      getElements();
      addListeners();
      statements = breakIntoComponents(inputString);
      console.log(statements);
      createAllFrames(statements);
      // parse(statements);
      // runInterpreter();
      // display();
    }

    function getElements() {
      runBtn = document.getElementById("btnRunCode");
    }

    function addListeners() {
      runBtn.addEventListener("click", fetchInput, false);
    }

    function fetchInput() {
      inputString = document.querySelector("#inputTextArea").textContent;
    }

    class Frame {
      id;
      parent;
      children;
      variables;
      functions;
      callStack;

      constructor(aFunctionName, index) {}

      addVariable(variable) {}
      addFunction(newFunction) {}
    }

    function createAllFrames(statements) {
      if(statements.length == 0) return;

      let newFrame = new Frame();

      for (let i = 0; i < statements.length; i++) {
            if (isFunctionDeclartion(statements[i])) {
                createAllFrames(statements.splice(i, statements.length - 1));
            } else if (isVariableDeclaration(statements, i)) {
            // add variable
        }
    }

    // function createFrames() {
    //     for(let i = 0; i < statements.length; i++) {

    //     }
    // }

    // function createFrame() {
    //     let newFrame = new Frame();

    //     for (let i = 0; i < statements.length; i++) {
    //         if (isFunctionDeclartion(statements[i])) {
    //             createFrame(statements.splice(i, statements.length - 1));
    //         } else if (isVariableDeclaration(statements, i)) {
    //         // add variable
    //     }
    //   }
    // }

    // function createFramesTemp(statements) {

    //   for (let i = 0; i < statements.length; i++) {
    //     if (isFunctionDeclartion(statements[i])) {
    //       // Skip to end of fn
    //       let fnStart = i;
    //       let fnEnd = findEndOfFunction(statements, i);
    //       i = end;
    //       // Good place for recursion on CreateFrame
    //     } else if (isVariableDeclaration(statements, i)) {
    //       // add variable
    //     }
    //   }
    // }

    // function parseArray(array) {
    //   var GlobalFrame = new frame("Global", 0);
    //   for (var index = 0; index < array.length; index++) {
    //     if (isFunction(array[index])) {
    //       var start = index;
    //       var end = findEOFLine(array, index);
    //       index = end;
    //       var functionStack = returnFunctionStack(array, start, end);
    //       var newFunction = new functions(array[start + 1], functionStack);
    //       GlobalFrame.addFunctionDefinition(newFunction, functionStack);
    //     } else if (isVarDeclartion(array[index])) {
    //       console.log(
    //         "is variable declartion at index: " +
    //           index +
    //           " null declaration " +
    //           isVarDeclartion(array[index])
    //       );
    //     }
    //   }
    //   console.log(GlobalFrame);
    // }
  </script>

  <script>
    window.addEventListener("load", function () {
      ///////////////////////////////////////building a statement then excuting it... this sets a new variable String xyz = "helloworld..."
      var newStatementStack = new statementStack(); //needs more work
      newStatementStack.addNode(new value(2));
      newStatementStack.addNode(new multiply());
      newStatementStack.addNode(new value(4));
      newStatementStack.addNode(new multiply());
      newStatementStack.addNode(new value(3));
      console.log(newStatementStack.pop(1));

      // console.log(newStatementStack.getStackNodeIndexOf(1));

      var globalFrame = new frame("global", 0); //i guess the function name for global frame is global.
      globalFrame.addVariables(new variable("integer1", 45));
      globalFrame.addVariables(new variable("integer2", 34));
      globalFrame.addVariables(new variable("string1", "hello"));
      globalFrame.addStatements(newStatementStack);
      globalFrame.addStatements(newStatementStack);
      globalFrame.addStatements(newStatementStack);

      var newFunction = new functions("newFunction");

      globalFrame.addFunction(newFunction);
      globalFrame.addFunction(newFunction);

      console.log(globalFrame);
    });
    function parseArray(array) {
      for (var index = 0; index < array.length; index++) {
        if (isFunction(array[index])) {
          var start = index;
          //console.log("is function at index: " + index + " and ends on line "+ findEOFLine(array, start));
        } else if (isVarDeclartion(array[index])) {
          console.log(
            "is variable declartion at index: " +
              index +
              " null declaration " +
              isVarDeclartion(array[index])
          );
        }
      }
    }
    function isFunction(string) {
      var isFunctionDeclartion = new RegExp(/((function) +[a-z,A-Z,0-9]*)/gim);
      //make improvements to this regexp here : https://regex101.com/r/9IiFmz/1
      return isFunctionDeclartion.test(string);
    }
    function isVarDeclartion(string) {
      //-1 for false, 0 var declared w/o assignment, 1 var declared /w assignment
      const isVariableDeclartionWithAssignment = new RegExp(
        /(var[ ]*[a-z, A-Z, 0-9]*[=][ ]*[a-z, A-Z, 0-9,+,-,*,/,",']*[;])/gm
      );
      //improve this regexp here https://regex101.com/r/FjoVKw/1
      const isVarDeclarNoAssignment = new RegExp(
        /(var[ ]*[a-z, A-Z, 0-9]*[;])/gm
      );
      //improve this regexp here https://regex101.com/r/T97bkY/1 //please add onto links. dont delete any previous if youre making changes.
      //console.log(isVarDeclarNoAssignment.test(string), string);
      if (isVarDeclarNoAssignment.test(string)) {
        return "isNullValue";
      }
      if (isVariableDeclartionWithAssignment.test(string) == true) {
        return "hasValue";
      }
    }
    function evaluteStack(statementStack) {
      //we first figure out what kind of statement it is...variable declaration,
    }
    function findEOFLine(array, start) {
      //raw string -> breakIntoComponents() first. start is the index of the array where a function declartion is detected.
      var count = 0;
      var endLine = -1;
      for (var x = start; x < array.length; x++) {
        if (array[x].search("{") > -1) {
          count = count + 1;
        }
        if (array[x].search("}") > -1) {
          count = count - 1;
        }
        if (count === 0 && array[x].search("}") > -1) {
          endLine = x;
          break;
        }
        // console.log(count);
      }
      return endLine;
    }
    function returnFunction(array) {}
    //**important notes: on a function call you will always need to initialize a the corrosponding frame... how?
    class frame {
      //a frame may contain variables, functions....or...maybe a callStack...
      frameIndex;
      id; //name
      size; //this tracks something...im not sure yet
      variables; //is an map [key, value] = [variablename, value]
      functions; //is an map ....//[functionName, functionFrame]
      previousNodeFrame; //a frame can only have one parent right...? this always leads back to the global...
      callStack;
      constructor(aFunctionName, index) {
        this.variables = new Map();
        this.functions = new Map();
        this.callStack = new Array();
        this.id = aFunctionName;
        this.frameIndex = index;
      }
      addVariables(variable) {
        //accepts an object of variable type
        // this.variables.push([variable.name,variable.value]);
        this.variables.set(variable.name, variable.value);
      }
      addFunction(newFunction) {
        //whenever you add a function (through encountering a function declaration token within this frame's context) you must create a new frame for everything in this function...i think
        var newFrame = new frame(newFunction.name + "_" + this.frameIndex); //we can also return the new frame created.
        newFrame.previousNodeFrame = this;
        this.functions.set(newFunction.name, newFrame);
      }
      addStatements(statementStack) {
        //is an object of statementStack
        this.callStack.push(statementStack);
      }
      returnChildFrame(id) {
        return this.functions.get(id);
      }
      returnParentFrame() {
        return this.previousNodeFrame;
      }
      eval() {}
      class;
    }
    class statementStack {
      size; //size of this stack
      statementHead; //always points back to the original head of this stack
      statementTail; //always points to the tail of this stack
      constructor() {
        //of a variable declartion, //function declarations/calls, variable name, valid pointers to objects basically.
        this.statementHead = null;
        this.statementTail = null;
        this.size = 0;
      }
      addNode(newNode) {
        //lets imagine the first
        if (this.statementHead === null) {
          //
          this.statementHead = newNode;
        } else if (this.statementTail === null) {
          this.statementTail = newNode;
          this.statementTail.previousNode = this.statementHead;
          this.statementHead.nextNode = this.statementTail;
        } else {
          // console.log("this newNode=", newNode);
          this.statementTail.nextNode = newNode;
          newNode.previousNode = this.statementTail;
          this.statementTail = newNode;
        }
        this.size++;
      }
      pop(index) {
        //if user provides no index input it pops the tail and returns it...
        console.log(index);
      }
      getStackNodeIndexOf(index) {
        var newStatementStack = null;
        var counter = 0;
        var temp = this.statementHead;
        // console.log(this);
        while (temp.nextNode != undefined) {
          temp = temp.nextNode;
          if (counter === index) {
            return temp;
          }
          counter++;
        }
        return "error";
      }
    }
    class functions {
      name; //what is your name
      nextNode; //ie var x = 2 or another function call -->this needs to be mapped to
      previousNode; //where did you come from?
      constructor(name) {
        this.name = name;
      }
    }
    class variable {
      type; //int, float, double, String is type even needed in javascript?? for simplicity's sake, please lets just get rid of types and only use strings.
      name; //what is your name?
      value; //what value do you store?
      nextNode; //next command.
      previousNode; //points to previous statement...?
      constructor(name, value) {
        //the minimum you need to declare a variable
        this.name = name;
        this.value = value;
      }
    }
    class value {
      value; //what is your value? a string? integer? float? i guess we could use javascript's amazingly flexible handling of types here...
      previousNode; //points to an arithmatic operation or to a variable...
      nextNode; //next node. a number sitting next to each other never makes sense. so a number have to be lead by and folowed by some sort of arithmatic
      constructor(value) {
        this.value = value;
      }
      addNode(newNode) {
        newNode.previousNode = this;
        this.nextNode = newNode;
      }
    }
    class equal {
      name;
      previousNode; //points to an object of either value() or variable();
      nextNode; //same here
      constructor() {
        this.name = "=";
      }
      eval() {
        this.previousNode.value = this.nextNode.value;
      }
    }
    class multiply {
      name;
      previousNode; //points to an object of either value() or variable();
      nextNode; //same here
      constructor() {
        this.name = "*";
      }
    }
    class add {
      name;
      constructor() {
        this.name = "+";
      }
    }
    class subtract {
      name;
      constructor() {
        this.name = "-";
      }
      eval() {
        return this.previousNode.value - this.nextNode.value;
      }
    }
    class divide {
      name;
      constructor() {
        this.name = "/";
      }
    }
  </script>
</html>
