<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script
      src="https://code.jquery.com/jquery-3.6.0.js"
      integrity="sha256-H+K7U5CnXl1h5ywQfKtSj8PCmoN9aaq30gDh27Xc0jk="
      crossorigin="anonymous"
    ></script>
    <script src="tools.js"></script>
    <link rel="stylesheet" href="style.css" />
    <title>parse</title>
  </head>
  <body>
    <div id="mainWrapper">
      <div id="inputSection">
        <p>Howdy Team</p>
        <textarea id="inputTextArea" style="width: 300px; height: 400px">
var globalNum0 = 0;
var globalNum1 = 0;

function oneLvlFunc0 () {
  var oneDeepNum0 = 1;
}

function oneLvlFunc1 () {
  var oneDeepNum1 = 1;
  function twoLvlFunc0 () {
    var twoDeepNum0 = 2;
  }
}

oneLvlFunc0();
oneLvlFunc1();



              </textarea
        >
        <br />
        <button id="runBtn">Run Code</button>
      </div>

      <div id="outputSection"></div>
    </div>
  </body>

  <script>
    window.addEventListener("load", () => {
      appMain();
    });

    // Get input string from input section
    let runBtn;
    let inputString;
    let expresions;
    let frames;

    function appMain() {
      getElements();
      addListeners();
      analyzeInput();
      //createFrames(statements);
      // runInterpreter();
      // display();
    }

    function getElements() {
      runBtn = document.getElementById("runBtn");
    }

    function addListeners() {
      runBtn.addEventListener("click", analyzeInput, false);
    }

    function analyzeInput() {
      fetchInput();
      expresions = breakIntoExpressions(inputString);
      console.log(expresions);

      let variables = [];
      let functions = [];

      // expresions.forEach((ex) => {
      //   // Check for keyword
      //   let reader = "";
      //   for (let i = 0; i < ex.length; i++) {
      //     while (ex[i] != " " || ex[i] != "=" || ex[i] != "(" || ex[i] != "{")
      //       console.log(ex[i]);
      //   }
      // });
    }

    function fetchInput() {
      inputString = document.querySelector("#inputTextArea").textContent;
    }

    class Frame {
      id;
      parent;
      variables;
      functionFrames;
      callStack;

      constructor(aFunctionName, index) {}

      addVariable(variable) {}
      addFunction(newFunction) {}
    }

    function createFrames(statements) {
      let idCounter = 0;
      createFrame(statements, idCounter);
    }

    function createFrame(statements, idCounter) {
      if (statements.length == 0) return;

      let newFrame = new Frame();

      if (idCounter == 0) parent = "Global";
      else id = idCounter;

      for (let i = 0; i < statements.length; i++) {
        if (isFunctionDeclartion(statements[i])) {
          // let functionSubstring = statements.slice(i, statements.length);
          // let functionFrame = createFrame(functionSubstring, idCounter++);
          // functionFrames.push(functionFrame);
        } else if (isVariableDeclaration(statements, i)) {
          console.log("Variable added to frame");
        }
      }

      return newFrame;
    }

    function isFunctionDeclartion(string) {
      var isFunctionDecl = new RegExp(/((function) +[a-z,A-Z,0-9]*)/gim);
      //make improvements to this regexp here : https://regex101.com/r/9IiFmz/1
      return isFunctionDecl.test(string);
    }

    function isVariableDeclaration(string) {
      //-1 for false, 0 var declared w/o assignment, 1 var declared /w assignment
      const declartionWithAssignment = new RegExp(
        /(var[ ]*[a-z, A-Z, 0-9]*[=][ ]*[a-z, A-Z, 0-9,+,-,*,/,",']*[;])/gm
      );
      //improve this regexp here https://regex101.com/r/FjoVKw/1
      const declarNoAssignment = new RegExp(/(var[ ]*[a-z, A-Z, 0-9]*[;])/gm);
      //improve this regexp here https://regex101.com/r/T97bkY/1 //please add onto links. dont delete any previous if youre making changes.
      //console.log(isVarDeclarNoAssignment.test(string), string);
      if (declarNoAssignment.test(string)) {
        return "isNullValue";
      }
      if (declartionWithAssignment.test(string) == true) {
        return "hasValue";
      }
    }
  </script>

  <!-- <script>
    window.addEventListener("load", function () {
      ///////////////////////////////////////building a statement then excuting it... this sets a new variable String xyz = "helloworld..."
      var newStatementStack = new statementStack(); //needs more work
      newStatementStack.addNode(new value(2));
      newStatementStack.addNode(new multiply());
      newStatementStack.addNode(new value(4));
      newStatementStack.addNode(new multiply());
      newStatementStack.addNode(new value(3));
      console.log(newStatementStack.pop(1));

      // console.log(newStatementStack.getStackNodeIndexOf(1));

      var globalFrame = new frame("global", 0); //i guess the function name for global frame is global.
      globalFrame.addVariables(new variable("integer1", 45));
      globalFrame.addVariables(new variable("integer2", 34));
      globalFrame.addVariables(new variable("string1", "hello"));
      globalFrame.addStatements(newStatementStack);
      globalFrame.addStatements(newStatementStack);
      globalFrame.addStatements(newStatementStack);

      var newFunction = new functions("newFunction");

      globalFrame.addFunction(newFunction);
      globalFrame.addFunction(newFunction);

      console.log(globalFrame);
    });
    function parseArray(array) {
      for (var index = 0; index < array.length; index++) {
        if (isFunction(array[index])) {
          var start = index;
          //console.log("is function at index: " + index + " and ends on line "+ findEOFLine(array, start));
        } else if (isVarDeclartion(array[index])) {
          console.log(
            "is variable declartion at index: " +
              index +
              " null declaration " +
              isVarDeclartion(array[index])
          );
        }
      }
    }
    function isFunction(string) {
      var isFunctionDeclartion = new RegExp(/((function) +[a-z,A-Z,0-9]*)/gim);
      //make improvements to this regexp here : https://regex101.com/r/9IiFmz/1
      return isFunctionDeclartion.test(string);
    }
    function isVarDeclartion(string) {
      //-1 for false, 0 var declared w/o assignment, 1 var declared /w assignment
      const isVariableDeclartionWithAssignment = new RegExp(
        /(var[ ]*[a-z, A-Z, 0-9]*[=][ ]*[a-z, A-Z, 0-9,+,-,*,/,",']*[;])/gm
      );
      //improve this regexp here https://regex101.com/r/FjoVKw/1
      const isVarDeclarNoAssignment = new RegExp(
        /(var[ ]*[a-z, A-Z, 0-9]*[;])/gm
      );
      //improve this regexp here https://regex101.com/r/T97bkY/1 //please add onto links. dont delete any previous if youre making changes.
      //console.log(isVarDeclarNoAssignment.test(string), string);
      if (isVarDeclarNoAssignment.test(string)) {
        return "isNullValue";
      }
      if (isVariableDeclartionWithAssignment.test(string) == true) {
        return "hasValue";
      }
    }
    function evaluteStack(statementStack) {
      //we first figure out what kind of statement it is...variable declaration,
    }
    function findEOFLine(array, start) {
      //raw string -> breakIntoComponents() first. start is the index of the array where a function declartion is detected.
      var count = 0;
      var endLine = -1;
      for (var x = start; x < array.length; x++) {
        if (array[x].search("{") > -1) {
          count = count + 1;
        }
        if (array[x].search("}") > -1) {
          count = count - 1;
        }
        if (count === 0 && array[x].search("}") > -1) {
          endLine = x;
          break;
        }
        // console.log(count);
      }
      return endLine;
    }
    function returnFunction(array) {}
    //**important notes: on a function call you will always need to initialize a the corrosponding frame... how?
    class frame {
      //a frame may contain variables, functions....or...maybe a callStack...
      frameIndex;
      id; //name
      size; //this tracks something...im not sure yet
      variables; //is an map [key, value] = [variablename, value]
      functions; //is an map ....//[functionName, functionFrame]
      previousNodeFrame; //a frame can only have one parent right...? this always leads back to the global...
      callStack;
      constructor(aFunctionName, index) {
        this.variables = new Map();
        this.functions = new Map();
        this.callStack = new Array();
        this.id = aFunctionName;
        this.frameIndex = index;
      }
      addVariables(variable) {
        //accepts an object of variable type
        // this.variables.push([variable.name,variable.value]);
        this.variables.set(variable.name, variable.value);
      }
      addFunction(newFunction) {
        //whenever you add a function (through encountering a function declaration token within this frame's context) you must create a new frame for everything in this function...i think
        var newFrame = new frame(newFunction.name + "_" + this.frameIndex); //we can also return the new frame created.
        newFrame.previousNodeFrame = this;
        this.functions.set(newFunction.name, newFrame);
      }
      addStatements(statementStack) {
        //is an object of statementStack
        this.callStack.push(statementStack);
      }
      returnChildFrame(id) {
        return this.functions.get(id);
      }
      returnParentFrame() {
        return this.previousNodeFrame;
      }
      eval() {}
      class;
    }
    class statementStack {
      size; //size of this stack
      statementHead; //always points back to the original head of this stack
      statementTail; //always points to the tail of this stack
      constructor() {
        //of a variable declartion, //function declarations/calls, variable name, valid pointers to objects basically.
        this.statementHead = null;
        this.statementTail = null;
        this.size = 0;
      }
      addNode(newNode) {
        //lets imagine the first
        if (this.statementHead === null) {
          //
          this.statementHead = newNode;
        } else if (this.statementTail === null) {
          this.statementTail = newNode;
          this.statementTail.previousNode = this.statementHead;
          this.statementHead.nextNode = this.statementTail;
        } else {
          // console.log("this newNode=", newNode);
          this.statementTail.nextNode = newNode;
          newNode.previousNode = this.statementTail;
          this.statementTail = newNode;
        }
        this.size++;
      }
      pop(index) {
        //if user provides no index input it pops the tail and returns it...
        console.log(index);
      }
      getStackNodeIndexOf(index) {
        var newStatementStack = null;
        var counter = 0;
        var temp = this.statementHead;
        // console.log(this);
        while (temp.nextNode != undefined) {
          temp = temp.nextNode;
          if (counter === index) {
            return temp;
          }
          counter++;
        }
        return "error";
      }
    }
    class functions {
      name; //what is your name
      nextNode; //ie var x = 2 or another function call ->this needs to be mapped to
      previousNode; //where did you come from?
      constructor(name) {
        this.name = name;
      }
    }
    class variable {
      type; //int, float, double, String is type even needed in javascript?? for simplicity's sake, please lets just get rid of types and only use strings.
      name; //what is your name?
      value; //what value do you store?
      nextNode; //next command.
      previousNode; //points to previous statement...?
      constructor(name, value) {
        //the minimum you need to declare a variable
        this.name = name;
        this.value = value;
      }
    }
    class value {
      value; //what is your value? a string? integer? float? i guess we could use javascript's amazingly flexible handling of types here...
      previousNode; //points to an arithmatic operation or to a variable...
      nextNode; //next node. a number sitting next to each other never makes sense. so a number have to be lead by and folowed by some sort of arithmatic
      constructor(value) {
        this.value = value;
      }
      addNode(newNode) {
        newNode.previousNode = this;
        this.nextNode = newNode;
      }
    }
    class equal {
      name;
      previousNode; //points to an object of either value() or variable();
      nextNode; //same here
      constructor() {
        this.name = "=";
      }
      eval() {
        this.previousNode.value = this.nextNode.value;
      }
    }
    class multiply {
      name;
      previousNode; //points to an object of either value() or variable();
      nextNode; //same here
      constructor() {
        this.name = "*";
      }
    }
    class add {
      name;
      constructor() {
        this.name = "+";
      }
    }
    class subtract {
      name;
      constructor() {
        this.name = "-";
      }
      eval() {
        return this.previousNode.value - this.nextNode.value;
      }
    }
    class divide {
      name;
      constructor() {
        this.name = "/";
      }
    }
  </script> -->
</html>
