<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script
      src="https://code.jquery.com/jquery-3.6.0.js"
      integrity="sha256-H+K7U5CnXl1h5ywQfKtSj8PCmoN9aaq30gDh27Xc0jk="
      crossorigin="anonymous"
    ></script>
    <script src="tools.js"></script>
    <link rel="stylesheet" href="style.css" />
    <title>parse</title>
  </head>
  <body>
    <div id="mainWrapper">
<div id="inputSection">
<p>Howdy Team</p>
<!-- var a = 2+2;
console.log(a); -->
<textarea id="inputTextArea" style="width: 300px; height: 400px">
function a(){
  var x = 10;
}
a();
a();
var a = 10;
var b = 3 + 3;
var c = a + b + 3;
abc = a + b + c;
</textarea
>
        <br />
        <button id="runBtn">Run Code</button>
      </div>

      <div id="outputSection"></div>
    </div>

    <!-- var VAR_0a = 0;
function FUNCT_0a(){
    var VAR_1a = 34;
    function FUNCT_1a(){
        var VAR_2a = 34;
    }
}
function FUNCT_0b(){

}
var VAR_0b = 3;
console.log(""); -->
  </body>

  <script>
    // Get input string from input section
    let runBtn;
    let inputString;
    let statements;
    let frames;

    function appMain() {
      getElements();
      addListeners();
      statements = breakIntoComponents(inputString);
      console.log(statements);
      // parse(statements);
      // runInterpreter();
      // display();
    }

    function getElements() {
      runBtn = document.getElementById("btnRunCode");
    }

    function addListeners() {
      runBtn.addEventListener("click", fetchInput, false);
    }

    function fetchInput() {
      inputString = document.querySelector("#inputTextArea").textContent;
    }
    var frameCount = 0;
    class Frame {
      //a frame may contain variables, functions....or...maybe a callStack...
      id; 
      parent;
      children;

      variables; //is an map [key, value] = [variablename, value]
      functions; //is an map ....//[functionName, functionFrame]

      callStack;

      constructor(aFunctionName, index) {
        this.variables = new Map();
        this.functions = new Map();
        this.callStack = new Array();
        this.id = aFunctionName;
        this.frameIndex = index;
      }

      addVariables(variable) {
        //accepts an object of variable type
        // this.variables.push([variable.name,variable.value]);
        this.variables.set(variable.name, variable.value);
      }
      addFunction(newFunction) {
        //whenever you add a function (through encountering a function declaration token within this frame's context) you must create a new frame for everything in this function...i think
        var newFrame = new frame(newFunction.name + "_" + this.frameIndex); //we can also return the new frame created.
        newFrame.previousNodeFrame = this;
        this.functions.set(newFunction.name, newFrame);
      }
      addStatements(statementStack) {
        //is an object of statementStack
        this.callStack.push(statementStack);
      }
      returnChildFrame(id) {
        return this.functions.get(id);
      }
      returnParentFrame() {
        return this.previousNodeFrame;
      }
      eval() {}
      class;
    }
  </script>

  <script>
window.addEventListener("load", function () {
  //step 1, we get javascript code from user as a raw string.
  var inputString = document.querySelector("#inputTextArea").textContent;
  //now we split the inputString into its induvidual components
  statements = breakIntoComponents(inputString);
  //findEOFLine(statements, 0);
  //console.log(findEOFLine(statements, 0));
  parseArray(0, statements.length ,statements, new frame("Global", 0));

  console.log(statements);

  // ///////////////////////////////////////building a statement then excuting it... this sets a new variable String xyz = "helloworld..."
  // var newStatementStack = new statementStack(); //needs more work
  // newStatementStack.addNode(new value(2));
  // newStatementStack.addNode(new multiply());
  // newStatementStack.addNode(new value(4));
  // newStatementStack.addNode(new multiply());
  // newStatementStack.addNode(new value(3));
  // console.log(newStatementStack.pop(1));

  // // console.log(newStatementStack.getStackNodeIndexOf(1));

  // var globalFrame = new frame("global", 0); //i guess the function name for global frame is global.
  // globalFrame.addVariables(new variable("integer1", 45));
  // globalFrame.addVariables(new variable("integer2", 34));
  // globalFrame.addVariables(new variable("string1", "hello"));
  // globalFrame.addStatements(newStatementStack);
  // globalFrame.addStatements(newStatementStack);
  // globalFrame.addStatements(newStatementStack);

  // var newFunction = new functions("newFunction");

  // globalFrame.addFunction(newFunction);
  // globalFrame.addFunction(newFunction);

  // console.log(globalFrame);
});
function parseArray(start, end, array, newFrameObject) {
  var Frame = newFrameObject;
  for (var index = start; index < array.length || index < end; index++) {
    
    if (isFunctionDeclarion(array[index])) {
      var start = index;
      var end = findEOFLine(array, index);
      var newFunction = new functions(Frame, array[index+1], start+2, end);
      //console.log(newFunction);
      Frame.addFunctionDefinition(newFunction, newFunction);
      index = end;
    } else if (isVarDeclartion(array[index])) {
      //console.log("is variable declartion at index: " + index);
      var keyValuePair = array[index+1].split("=");
      keyValuePair[0] = keyValuePair[0].trim();
      
      var variableName = keyValuePair[0];
      var expression = keyValuePair[1];

      expression = breakExpressionIntoComponents(expression);

      // console.log(expression);
      
      //var newVarible = new variable(keyValuePair[0], eval(keyValuePair[1])); //cheater!
      //Frame.addVariables(newVarible);
      index++;
      index++;
    }else if(detectStatementVariableReassignment(array[index])){
      console.log("variable reassigbment on line ", index);
    }
    else if(detectFunctionCalls(array[index])){
      var newFrame = new frame("FRAME__" + array[index]+index, index);
      console.log(array[index]);
      console.log(newFrame);

      var functionCalled = Frame.returnFunctionDefinitions(array[index]);
      newFrame = functionCalled.Frame;
      //console.log("function called", functionCalled);
      //parseArray(functionCalled.start, functionCalled.end, array, newFrame);
    }
  }
  if(Frame.id != "Global"){
    parseArray(Frame.returnIndex, array.length,)
  }
  console.log(Frame);
}
function returnFunction(array) {}
//**important notes: on a function call you will always need to initialize a the corrosponding frame... how?
class frame {
  //a frame may contain variables, functions....or...maybe a callStack...
  id; //name
  size; //this tracks something...im not sure yet
  variables; //is an map [key, value] = [variablename, value]
  functions; //is an map ....//[functionName, functionFrame]
  callStack;
  previousNodeFrame;
  returnIndex;
  constructor(aFunctionName, index) {
    this.variables = new Map();
    this.functions = new Map();
    this.callStack = new Array();
    this.id = aFunctionName;
    this.returnIndex = index + 1;
  }
  addVariables(variable) {
    //accepts an object of variable type
    // this.variables.push([variable.name,variable.value]);
    this.variables.set(variable.name, variable.value);
  }
  addFunctionDefinition(newFunction, functionStack) {
    //whenever you add a function (through encountering a function declaration token within this frame's context)
    this.functions.set(newFunction.name, functionStack);
  }
  addStatements(statementStack) {
    //is an object of statementStack
    this.callStack.push(statementStack);
  }
  returnFunctionDefinitions(functionCall) {
    var newCall = functionCall.split(";");
    return this.functions.get(newCall[0]);
  }
  returnParentFrame() {
    return this.previousNodeFrame;
  }
  peak(){
    return this;
  }
  returnPreviousFrame(){
    return this.previousNodeFrame;
  }
}
class statementStack {
  size; //size of this stack
  statementHead; //always points back to the original head of this stack
  statementTail; //always points to the tail of this stack
  constructor() {
    //of a variable declartion, //function declarations/calls, variable name, valid pointers to objects basically.
    this.statementHead = null;
    this.statementTail = null;
    this.size = 0;
  }
  addNode(newNode) {
    //lets imagine the first
    if (this.statementHead === null) {
      //
      this.statementHead = newNode;
    } else if (this.statementTail === null) {
      this.statementTail = newNode;
      this.statementTail.previousNode = this.statementHead;
      this.statementHead.nextNode = this.statementTail;
    } else {
      // console.log("this newNode=", newNode);
      this.statementTail.nextNode = newNode;
      newNode.previousNode = this.statementTail;
      this.statementTail = newNode;
    }
    this.size++;
  }
  pop(index) {
    //if user provides no index input it pops the tail and returns it...
    console.log(index);
  }
  getStackNodeIndexOf(index) {
    var newStatementStack = null;
    var counter = 0;
    var temp = this.statementHead;
    // console.log(this);
    while (temp.nextNode != undefined) {
      temp = temp.nextNode;
      if (counter === index) {
        return temp;
      }
      counter++;
    }
    return "error";
  }
}
class functions {
  name; //what is your name
  start; //index of array
  end; //end of array
  Frame; //a frame can only have one parent right...? this always leads back to the global...
  constructor(frame, name, start, end) {
    this.Frame = frame;
    this.name = name;
    this.start = start;
    this.end = end;
  }
}
class variable {
  type; //int, float, double, String is type even needed in javascript?? for simplicity's sake, please lets just get rid of types and only use strings.
  name; //what is your name?
  value; //what value do you store?
  nextNode; //next command.
  previousNode; //points to previous statement...?
  constructor(name, value) {
    //the minimum you need to declare a variable
    this.name = name;
    this.value = value;
  }
}
class value {
  value; //what is your value? a string? integer? float? i guess we could use javascript's amazingly flexible handling of types here...
  previousNode; //points to an arithmatic operation or to a variable...
  nextNode; //next node. a number sitting next to each other never makes sense. so a number have to be lead by and folowed by some sort of arithmatic
  constructor(value) {
    this.value = value;
  }
  addNode(newNode) {
    newNode.previousNode = this;
    this.nextNode = newNode;
  }
}
class equal {
  name;
  previousNode; //points to an object of either value() or variable();
  nextNode; //same here
  constructor() {
    this.name = "=";
  }
  eval() {
    this.previousNode.value = this.nextNode.value;
  }
}
class multiply {
  name;
  previousNode; //points to an object of either value() or variable();
  nextNode; //same here
  constructor() {
    this.name = "*";
  }
}
class add {
  name;
  constructor() {
    this.name = "+";
  }
}
class subtract {
  name;
  constructor() {
    this.name = "-";
  }
  eval() {
    return this.previousNode.value - this.nextNode.value;
  }
}
class divide {
  name;
  constructor() {
    this.name = "/";
  }
}
  </script>
</html>
