<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script
      src="https://code.jquery.com/jquery-3.6.0.js"
      integrity="sha256-H+K7U5CnXl1h5ywQfKtSj8PCmoN9aaq30gDh27Xc0jk="
      crossorigin="anonymous"
    ></script>
    <script src="tools.js"></script>
    <script src="regexDefinitions.js"></script>
    <link rel="stylesheet" href="style.css" />
    <title>parse</title>
  </head>
  <body>
    <div id="mainWrapper">
<div id="inputSection">
<p>Howdy Team</p>
<!-- var a = 2+2;
console.log(a); -->
<textarea id="inputTextArea" style="width: 300px; height: 400px">
  var a = 10;
  function b(){
    function c(){
      var xyz = 10;
    }
    
    a = 5; 
    c();
    console.log(d);
  }
  function c(){
    d = 6;
    var a = 7;
    e = 9;
    function f(){
      a = 2;
    }
    f();
  }
  b();
</textarea
>
<br />
<button id="runBtn" onclick="initParse()">Run Code</button>
</div>

<div id="outputSection"></div>
</div>
</body>

  <script>
function initParse() {
  console.clear();
  //step 1, we get javascript code from user as a raw string.
  var inputString = document.querySelector("#inputTextArea").value;
  //now we split the inputString into its induvidual components
  statements = breakIntoComponents(inputString);
  //findEOFLine(statements, 0);
  //console.log(findEOFLine(statements, 0));
  var newFunction = new functionDEF("Global", 0, statements.length);

  console.log(statements);

  var FinalFrame = parseArray(0,statements, new frame(newFunction, statements.length));
  console.log(FinalFrame);
}

function parseArray(start, array, Frame) {
  //var Frame = newFrameObject;
  // console.log("current frame: ", Frame.returnParentFrame());
  for (var index = Frame.start; index <= Frame.end; index++) {
   console.log("index ", index);
    //DETECT FUNCTION DECLATION TOKEN
   if (isFunctionDeclarion(array[index])) {
      var start = index;
      var end = findEOFLine(array, index);
      var newFunction = new functionDEF(array[index+ 1], start+2, end);
      //console.log(newFunction);
      Frame.addFunctionDefinition(newFunction);
      index = end;
      //DETECT VARIABLE DECLATION TOKEN
    } else if (isVarDeclartion(array[index])) {
      //console.log("is variable declartion at index: " + index);
      var keyValuePair = array[index+1].split("=");
      keyValuePair[0] = keyValuePair[0].trim();
      
      var variableName = keyValuePair[0];
      var expression = keyValuePair[1];

      expression = breakExpressionIntoComponents(expression);

      // console.log(expression);
      
      var newVarible = new variable(keyValuePair[0], eval(keyValuePair[1])); //cheater!
      Frame.addVariables(newVarible);
      index++;
      //DETECT VARIABLE REASSIGNMENT
    }else if(detectStatementVariableReassignment(array[index])){
      // console.log("variable reassigbment on line ", index);
      // console.log(array[index]);
      var tempArray = array[index].split("=");
      var variableName = tempArray[0].trim();
      var expression = tempArray[1].split(";");
      expression = expression[0];
      var newFrame = returnFrameContainingVariable(Frame, variableName);
      newFrame.variables.set(variableName, eval(expression));
      //console.log(newFrame.id);
    }
    else if(detectFunctionCalls(array[index])){
      var newFrame = returnFrameContainingFunctionDEF(Frame, array[index]);
      var newFunctionDef = newFrame.returnFunctionDefinitions(array[index]);
      var newFrame = new frame(newFunctionDef, index);
      newFrame.previousNodeFrame = Frame;
      Frame.addChildFrame(newFrame);
     parseArray(newFunctionDef.getStart, array, newFrame);
    }
  }

  if(Frame.id === "Global"){
    return Frame;
  }
}
function returnFrameContainingVariable(newFrame, variableName){
  while (!newFrame.variables.has(variableName) && typeof (newFrame.returnParentFrame()) !== "undefined") {
    newFrame = newFrame.returnParentFrame();
  }
  return newFrame;
}
function returnFrameContainingFunctionDEF(newFrame, functionName){
  while (!newFrame.returnFunctionDefinitions(functionName) && typeof (newFrame.returnParentFrame()) !== "undefined") {
    newFrame = newFrame.returnParentFrame();
  }
  return newFrame;
}
function returnFunction(array) {}
//**important notes: on a function call you will always need to initialize a the corrosponding frame... how?
class frame {
  //a frame may contain variables, functionDEF....or...maybe a callStack...
  id; //name
  fIndex; //this tracks something...im not sure yet
  variables; //is an map [key, value] = [variablename, value]
  functionDefinitions; //is an map ....//[functionName, functionDefinition {start, end}]
  childrenFrames;
  previousNodeFrame;
  returnToIndex;
  start;
  end;
  constructor(aFunctionDefinition, index) {
    this.variables = new Map();
    this.functionDefinitions = new Map();
    this.childrenFrames = new Array();
    this.id = aFunctionDefinition.getName();
    this.returnToIndex = index + 1;
    this.start = aFunctionDefinition.getStart();
    this.end = aFunctionDefinition.getEnd();
    this.fIndex = index;
  }
  addVariables(variable) {
    //accepts an object of variable type
    // this.variables.push([variable.name,variable.value]);
    this.variables.set(variable.name, variable.value);
  }
  addFunctionDefinition(newFunction) {
    //whenever you add a function (through encountering a function declaration token within this frame's context)
    this.functionDefinitions.set(newFunction.name, newFunction);
  }
  addChildFrame(childFrame){
    this.childrenFrames.push(childFrame);
  }
  addStatements(statementStack) {
    //is an object of statementStack
    this.callStack.push(statementStack);
  }
  returnFunctionDefinitions(functionCall) {
    var newCall = functionCall.split(";");
    return this.functionDefinitions.get(newCall[0]);
  }
  returnParentFrame() {
    return this.previousNodeFrame;
  }
  peak(){
    return this;
  }
  get returnPreviousFrame(){
    return this.previousNodeFrame;
  }
  get returnToIndex(){
    return parseInt(this.returnToIndex);
  }
}
class functionDEF {
  name; //what is your name
  start; //index of array
  end; //end of array...
  constructor(name, start, end) {
    this.name = name;
    this.start = start;
    this.end = end;
  }
  getStart(){
    return parseInt(this.start);
  }
  getEnd(){
    return parseInt(this.end);
  }
  getName(){
    return this.name;
  }
}
class statementStack {
  size; //size of this stack
  statementHead; //always points back to the original head of this stack
  statementTail; //always points to the tail of this stack
  constructor() {
    //of a variable declartion, //function declarations/calls, variable name, valid pointers to objects basically.
    this.statementHead = null;
    this.statementTail = null;
    this.size = 0;
  }
  addNode(newNode) {
    //lets imagine the first
    if (this.statementHead === null) {
      //
      this.statementHead = newNode;
    } else if (this.statementTail === null) {
      this.statementTail = newNode;
      this.statementTail.previousNode = this.statementHead;
      this.statementHead.nextNode = this.statementTail;
    } else {
      // console.log("this newNode=", newNode);
      this.statementTail.nextNode = newNode;
      newNode.previousNode = this.statementTail;
      this.statementTail = newNode;
    }
    this.size++;
  }
  pop(index) {
    //if user provides no index input it pops the tail and returns it...
    console.log(index);
  }
  getStackNodeIndexOf(index) {
    var newStatementStack = null;
    var counter = 0;
    var temp = this.statementHead;
    // console.log(this);
    while (temp.nextNode != undefined) {
      temp = temp.nextNode;
      if (counter === index) {
        return temp;
      }
      counter++;
    }
    return "error";
  }
}
class variable {
  type; //int, float, double, String is type even needed in javascript?? for simplicity's sake, please lets just get rid of types and only use strings.
  name; //what is your name?
  value; //what value do you store?
  nextNode; //next command.
  previousNode; //points to previous statement...?
  constructor(name, value) {
    //the minimum you need to declare a variable
    this.name = name;
    this.value = value;
  }
}
class value {
  value; //what is your value? a string? integer? float? i guess we could use javascript's amazingly flexible handling of types here...
  previousNode; //points to an arithmatic operation or to a variable...
  nextNode; //next node. a number sitting next to each other never makes sense. so a number have to be lead by and folowed by some sort of arithmatic
  constructor(value) {
    this.value = value;
  }
  addNode(newNode) {
    newNode.previousNode = this;
    this.nextNode = newNode;
  }
}
class equal {
  name;
  previousNode; //points to an object of either value() or variable();
  nextNode; //same here
  constructor() {
    this.name = "=";
  }
  eval() {
    this.previousNode.value = this.nextNode.value;
  }
}
class multiply {
  name;
  previousNode; //points to an object of either value() or variable();
  nextNode; //same here
  constructor() {
    this.name = "*";
  }
}
class add {
  name;
  constructor() {
    this.name = "+";
  }
}
class subtract {
  name;
  constructor() {
    this.name = "-";
  }
  eval() {
    return this.previousNode.value - this.nextNode.value;
  }
}
class divide {
  name;
  constructor() {
    this.name = "/";
  }
}
  </script>
</html>
