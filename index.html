<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script   src="https://code.jquery.com/jquery-3.6.0.js"   integrity="sha256-H+K7U5CnXl1h5ywQfKtSj8PCmoN9aaq30gDh27Xc0jk="   crossorigin="anonymous"></script>
    <script src="tools.js"></script>
    <title>parse</title>
</head>
<body>

    <p> Howdy Team</p>
<!-- var a = 2+2;
console.log(a); -->
<textarea id="inputTextArea" style="width: 300px; height: 400px;">
var a = 10;
function b(){
    a = 5;  
    c();
    console.log(d);
}
function c(){
    d = 6;
    var a = 7;
    e = 9;
    function f(){
    a = 2;
    }
    f();
}
b();
</textarea>
<!-- var VAR_0a = 0;
function FUNCT_0a(){
    var VAR_1a = 34;
    function FUNCT_1a(){
        var VAR_2a = 34;
    }
}
function FUNCT_0b(){

}
var VAR_0b = 3;
console.log(""); -->
</body>
<script>
window.addEventListener("load", function(){
//step 1, we get javascript code from user as a raw string.
var inputString = document.querySelector("#inputTextArea").textContent;
//now we split the inputString into its induvidual components
statements = breakIntoComponents(inputString);

// console.log(statements);

///////////////////////////////////////building a statement then excuting it... this sets a new variable String xyz = "helloworld..."
// var newVariable = new variable("String", "xyz", null);
// var newNodeEquals = new equal();
// var newNodeValue = new value(2);
// newNodeValue.previousNode = newNodeEquals;
// newNodeEquals.previousNode = newVariable;
// newNodeEquals.nextNode = newNodeValue;
// newVariable.nextNode = newNodeEquals;
// console.log(newVariable);
// newVariable.eval(); //eval in this case will return undefined... there is no output when we are setting a variable to a value...right?
// // console.log(var x = 2); this is invalid, which means the logic might work...
// console.log(newVariable.value); //okay... this is working...i think this maybe the correct way to start setting things up...

// ///building a multiplation statement and excuting it... this statement evalute the expression zyx(4) * value(3...)
// // newVariable = new variable("int", "zyx", null);
// var newNodeMultiply = new multiply();
// newNodeValue = new value(3);

// newNodeValue.previousNode = newNodeMultiply; //we need a function for this...
// newNodeMultiply.previousNode = newVariable;
// newNodeMultiply.nextNode = newNodeValue;
// newVariable.nextNode = newNodeMultiply;
// console.log(newVariable);
// //console.log(2 * 3) an expression will always return a value.
// console.log(newVariable.eval()); //okay... this is working...i think this maybe the correct way to start setting things up... eval in this case should return a 
//                              //value since it is an expression

//another test expression... 2*4*8, eval() = 14 //we ignore order of operations cause:  too difficult. if we need to do anything more than simple arithmatic, default
                                                //we use js eval();
var newStatementStack = new statementStack(); //needs more work
newStatementStack.addNode(new value(2));
newStatementStack.addNode(new multiply());
newStatementStack.addNode(new value(4));
newStatementStack.addNode(new multiply());
newStatementStack.addNode(new value(3));
// console.log(newStatementStack.statementHead);

// console.log(newStatementStack.getStackNodeIndexOf(1));

var globalFrame = new frame("global"); //i guess the function name for global frame is global.
globalFrame.addVariables(["variableA", 2]);
globalFrame.addVariables(["variableB", "hello"]);
globalFrame.addVariables(["variableB", 3.67]);
globalFrame.addStatements(newStatementStack);
globalFrame.addStatements(newStatementStack);
globalFrame.addStatements(newStatementStack);

var newFunction = new functions("functionSCOPE1");

globalFrame.addFunction(newFunction);


console.log(globalFrame);
}); 

function breakIntoComponents(inputString){ //this needs more work. //will be rewritten
    //first, we must first remove all line breaks and whitespace. we also assume that user will wrote in good style. that means they include semi colon.
    inputString = inputString.replace(/\n/g, '');
    inputString = inputString.replace(/\s/g,'');
    newArray = inputString.split(/([;}]+)/);
    var outArray = new Array();
    for(index = 0; index < newArray.length; index++){
        if(newArray[index].includes("function")){
            let temp = newArray[index].split(/(function)/);
            outArray.push(temp[1]);
            outArray.push(temp[2]);

        }else if(newArray[index].includes("var")){
            let temp = newArray[index].split(/(var)/);
            outArray.push(temp[1]);
            outArray.push(temp[2]);
        }else{
            outArray.push(newArray[index]);
        }
    }
    //what if we can just do this...
    // eval("console.log('holy fuck no way...');var x = 23; console.log(x);"); //
    // eval("var x=7364;");
    // eval("console.log(x);"); 
    // console.log(x);
   //while this could work, it defeats the point of the assignment. well...in any case..xwxx
    return outArray;
}
class frame { //a frame may contain variables, functions....or...maybe a callStack...
    id;
    variables; //is an array
    functions; //is an array ....//function is called...then
    previousNodeFrame //a frame can only have one parent right...? this always leads back to the global...
    callStack;
    constructor(aFunctionName){
        this.variables = new Array();
        this.functions = new Array();
        this.callStack = new Array();
        this.id = aFunctionName;
    }
    addVariables(variable){ //this stores variable declared in a list [name, key];
        this.variables.push(variable);
    }
    addFunction(newFunction){//whenever you add a function (through encountering a function declaration token within this frame's context) you must create a new frame for everything in this function...i think
        this.functions.push([newFunction.name], new frame(newFunction.name));
    }
    addStatements(statementStack){//is an object of statementStack
        this.callStack.push(statementStack);
    }
}
class statementStack {
    size;
    statementHead; //always points back to the original head of this stack
    statementTail;//always points to the tail of this stack
    constructor(){ //of a variable declartion, //function declarations/calls, variable name, valid pointers to objects basically.
        this.statementHead = null;
        this.statementTail = null;
        this.size = 0;
    }
    // newNodeValue.previousNode = newNodeMultiply; //we need a function for this...
    // newNodeMultiply.previousNode = newVariable;
    // newNodeMultiply.nextNode = newNodeValue;
    // newVariable.nextNode = newNodeMultiply;  
    eval(){
        //we should work from the end to the front...right?
        var results = this.statementHead.eval();
        // while(this.statementTail.eval() != results){
        //     results = this.statementTail.eval();
        // }
        return results;
    }
    addNode(newNode){ //lets imagine the first 
        if(this.statementHead === null){ //
            this.statementHead = newNode;
        }else if(this.statementTail === null){
            this.statementTail = newNode;
            this.statementTail.previousNode = this.statementHead;
            this.statementHead.nextNode = this.statementTail;
        }else{
            // console.log("this newNode=", newNode);
            this.statementTail.nextNode = newNode;
            newNode.previousNode = this.statementTail;
            this.statementTail = newNode;
        }
        this.size++;
    }
    getStackNodeIndexOf(index){
        var newStatementStack = null;
        var counter = 0;
        var temp = this.statementHead;
        // console.log(this);
        while(temp.nextNode!= undefined){
            temp = temp.nextNode;
            if(counter === index){
                return temp;
            }
            counter++;
        }
        return "error";
    }
}
class functions {
    name; //what is your name
    nextNode; //ie var x = 2 or another function call -->
    previousNode; //where did you come from?
    constructor(name){
        this.name = name;
    }
}
class variable {
    //type; //int, float, double, String is type even needed in javascript?? for simplicity's sake, please lets just get rid of types and only use strings.
    name; //what is your name?
    value; //what value do you store?
    nextNode; //next command. 
    previousNode; //points to previous statement...? 
    constructor(type, name){ //the minimum you need to declare a variable
        this.type = type;
        this.name = name;
        this.value = null;
    }
    eval(){
        return this.nextNode.eval();
    }
}
class value{
    value; //what is your value? a string? integer? float? i guess we could use javascript's amazingly flexible handling of types here...
    previousNode; //points to an arithmatic operation or to a variable...
    nextNode; //next node. a number sitting next to each other never makes sense. so a number have to be lead by and folowed by some sort of arithmatic 
    constructor(value){
        this.value = value;
    }
    addNode(newNode){
        newNode.previousNode = this;
        this.nextNode = newNode;
    }
    eval(){
        if(!this.nextNode){
            return this.value;
        }else{
            return this.nextNode.eval();
        }
    }
}
class equal{
    name;
    previousNode; //points to an object of either value() or variable();
    nextNode;//same here
    constructor(){
        this.name = "=";
    }
    eval(){
        this.previousNode.value = this.nextNode.value;
    }
}
class multiply{
    name;
    previousNode; //points to an object of either value() or variable();
    nextNode;//same here
    constructor(){
        this.name = "mult";
    }
    eval(){
        var product = new value(this.previousNode.value * this.nextNode.value) ;
        this.value = product;

    }    
}
class add{
    name;
    constructor(){
        this.name = "add"
    }
    eval(){
        return this.previousNode.value + this.nextNode.value;
    }
}
class subtract{
    name;
    constructor(){
        this.name = "sub"
    }
    eval(){
        return this.previousNode.value - this.nextNode.value;
    }
}
class divide{
    name;
    constructor(){
        this.name = "div"
    }
    eval(){
        return this.previousNode.value * (1.0/this.nextNode.value);
    }
}
</script>
</html>